Feature Request: Include Search Filters for Tracks by Their Audio-Features
November 1st 2017


OBJECTIVE
To give users the ability to filter search results by desired audio-features, such as “danceability”, “energy”, “liveness” and “tempo” .
BACKGROUND 
Currently, Jammming supports the ability to search for tracks with one search term. With millions of songs and possibly thousands of potential results, a search filter by song type would be useful for users trying to make a playlist to accompany a certain activity. For example, playlists tailored for dance routines or workouts.
This feature accomplishes the following:
* Displays a list of track filter options with a range for four different audio-feature aspects:
   * Danceability
   * Energy
   * Liveness
* Allows a user to select one or more of these filters for the search of tracks with desired ranges of 0% to 100%.
* Allows the user to search tracks with either none, one, two, or all three of the filters.
TECHNICAL DESIGN
Display Search Filters 
This feature doesn’t require any new components, but rather an update to the SearchBar Component with the added search filter options. However, to avoid long and unnecessary code formation we can (and I suggest) we create a new SearchFilters Component. This will also allow the programmer to experiment with the new code without the risk of making the existing code unusable.
The new SearchFilters Component will display selectable buttons for the three search filter buttons, along with a slide bar for the value of each filter from 0 to 100%.
As such, the SearchFilters Component should have an initial state for these values with a key of “filtersSelected” initialized to a default boolean of “false”.  (So the user can still search without audio feature filters if desired.) Then three more keys should be declared, each with a key of <filterOptionName> containing an object with two key values. The first should be a boolean initially set to false. The second should be a declared as a float to indicate the desired level selected by the user, set to a default of 0.5. (<filterOptionName> should be the unique audio-feature of each filter respectively, such as “energyLevel: 0.5,” etc.)
The Component should also have a filter() method bound to this in the constructor. In the method, it should pass the state of each filterOptionName to App.js, if the state filtersSelected is set to true. 
Also, within the SearchFilters component, a method should be declared to handle each filter option value change that sets the corresponding state to the user’s desired level. ( ex:   handleEnergyLevelChange(e) {   this.setState({energyLevel: e.target.value});   }   etc. etc.) 
Retrieve Audio Features
Unfortunately Spotify doesn’t offer the search option for certain audio features through the web API when directly searching for a track, but it does allow us to return an object with a track’s audio features for multiple track ID’s (up to 100). As such, we can filter through the search results we already call with the Spotify.searchSpotify() method. This search method currently defaults at 20, but maxes out at 50. Currently we don’t set the results, so the default is called. Since our filter options will theoretically limit the results significantly, I suggest appending the current Spotify.searchSpotify() method’s current url call with “&limit=50”.
After doing such we can get the audio features of each track returned by creating a method in the Spotify object called Spotify.getAudioFeatures(). This method will call to the endpoint https://api.spotify.com/v1/audio-features and we will have to pass the user’s current access token into the Authorization Header object. The method should also take in an array parameter called “trackIDs”  and pass it along as a query param at the end of the endpoint url “/&ids=${trackIDS.join(‘.’)}” as the API requires a comma separated list without the brackets of an array.
Once Spotify.getAudioFeatures() returns the audio features (should be an array of objects) we want to return an array of trackAudioFeatures using a .map() of each desired filter key, such as “jsonResponse.danceability,  jsonResponse.energy,  jsonResponse.liveness” and “jsonResponse.id”. The later will be used to filter which search results are displayed to the user.
Filter Search results
In App.js, we will add a method for retrieving audio features and updating the search results. This method should retrieve the audio features of the tracks searched for by the user and compare them to the user’s desired levels and update the generated SearchResults state accordingly.
This will require a new state in App.js called audioFeatures. It will be set to a default empty array.
Then we will create a method called filterAudioFeatures(). This method will set a variable to the trackIDs of the current track IDs in the searchResults state by mapping the current state’s ID key of each track object in the object array. Then call the Spotify.getAudioFeatures() method with the array trackIDs as the parameter. (Set up similarly to how the app currently finds and passes the track URIs in the savePlaylist() method.)
Once the promise is returned holding the audio-features object, we will have to compare the values of each feature with the state of props from SearchFilters component. If the value of the track’s audio features isn’t within a range of +/- 15% (maybe +/- 20% to lower the possibility of none of the tracks meeting the user’s desires) then find that track in the SearchResults state array and remove it from the array so only the tracks meeting the user’s desired values are displayed. (Recommend creating a temporary array of objects that hold these tracks before setting the state of SearchResults to that updated value, so as to limit possible bugs from trying to change the state dynamically.)
Once the value of the SearchReults state is updated to the new object list, the user should only see the tracks that match the filtered desires.
CAVEATS
SearchFilters Component
With this implementation, we create a component separate from the current working app. This will allow the developer to bug test the filter methods and logic without risking breaking already working code. Currently, a checkbox is supposed to update a state that will tell App.js to only filter the search if it’s checked (truthy). This might cause a delay or display bugs while the app fetches and runs the code that will filter the search results. As such, we should consider making it a button that the user presses which shows a loading screen while the code calls and decides which tracks meet the criteria. This will solve latency issues (such as the full search results being displayed while the app fetches the audio features and updates the state) that will cause laggy or an undesirable user experience.
This will require a separate onClick props in the SearchFilters component that calls the a separate method to be declared and called if clicked. This is easily done by binding the filterAudioFeatures() in App.js to this in the constructor and passing it as a props to the SearchFilters component.
App.js Spotify API Requests
We could implement the feature as a checkbox and solve potential latency issues that would cause undesirable UX of displaying the search results and the filtered results by changing the current search call to wait to update the SearchResults state until after the audio features filter method executes with an if statement that checks if the props passed from the SearchFilters component is truthy or not. If not, it will update the state will little to no delay to the user. If it is truthy, then it will wait for the Spotify.getAudioFeatures() to return and then compare the tracks that meet the filters to the returned search results before updating the state of SearchReults in App.search() method. 
However, this will require the developer to change code that already works and risk breaking currently usable and properly functioning code. It shouldn’t be an issue with Git back ups, but the separate button in the SearchFilters component would make logical sense first because the developer could confirm the filter is functioning properly on already returned tracks before easily changing it to a truthy state that is checked in the current App.search() method. So, this way of proceeding shouldn’t be followed through, as it can easily be changed after the more complex coding is complete and functioning.